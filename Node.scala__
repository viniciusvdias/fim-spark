package fim.fptree

import scala.annotation.tailrec
import scala.collection.mutable.Map

object Node {
  val Null = null
  val emptyItemId = Int.MinValue
  val emptyChildren = Array.empty[Node]
  def emptyRNode = RNode(emptyItemId, 0)
  def emptyTNode = TNode(emptyItemId, 0)
}

// extra field *tids* for mu-mining phase
case class TNode(var itemId: Int,
    var count: Int,
    var parent: Node = Node.Null,
    var link: Node = Node.Null,
    var firstChild: Node = Node.Null,
    var sibling: Node = Node.Null,
    var tids: Int = 0) extends Node

// regular node
case class RNode(var itemId: Int,
    var count: Int,
    var parent: Node = Node.Null,
    var link: Node = Node.Null,
    var firstChild: Node = Node.Null,
    var sibling: Node = Node.Null) extends Node

case class ChildrenIterator(var node: Node) extends Iterator[Node] {
  def hasNext = node != Node.Null
  def next = { val nextNode = node; node = node.sibling; nextNode }
}

trait Node {
  var itemId: Int
  var count: Int
  var parent: Node
  var link: Node
  var firstChild: Node
  var sibling: Node

  def isRoot: Boolean = (parent == Node.Null)

  def children = ChildrenIterator(this.firstChild)

  def addChild(c: Node) = {
    c.sibling = this.firstChild
    this.firstChild = c
    c.parent = this
  }

  def findChild(childId: Int): Option[Node] = {
    var child = this.firstChild
    while (child != Node.Null) {
      if (child.itemId == childId) return Some(child)
      child = child.sibling
    }
    return None
  }

  def insertItems(items: Iterable[Int],
      linksTable: Map[Int,Node],
      count: Int,
      updateLinksTable: Boolean = true,
      isTransaction: Boolean = false) = {

    val transIter = items.iterator
    
    var currNode = this
    while (transIter.hasNext) {
      val it = transIter.next

      currNode.findChild(it) match {
        case None => 
          val newNode =
            if (isTransaction) TNode(it, count)
            else RNode(it, count)

          if (updateLinksTable) {
            val firstNode = linksTable.getOrElse(it, Node.Null)
            newNode.link = firstNode
            linksTable(it) = newNode
          }

          currNode.addChild(newNode)

          currNode = newNode

        case Some(c) =>
          c.count += count
          currNode = c
      }
    }

    currNode match {
      case tNode: TNode => tNode.tids += 1; tNode
      case rNode: RNode => rNode
    }
  }

  //override def toString = {
  //  def toStringRec(tree: Node, level: Int): String = {
  //    var str = "(tree=" + System.identityHashCode(tree) + ", itemId=" + tree.itemId + ", count=" + tree.count

  //    if (tree.parent != null) str += ", parent=" + tree.parent.itemId
  //    else str += ", parent=-1"
  //    if (tree.link != null) str += ", link=(" +
  //    tree.link.itemId + ", hash=" + System.identityHashCode(tree.link) + ")"
  //    else str += ", link=-1"

  //    str += ", #children=" + tree.children.size
  //    tree match {
  //      case tNode: TNode => str += ", tids=" + tNode.tids + ")\n"
  //      case rNode: RNode => str += ")\n"
  //    }

  //    if (!tree.children.isEmpty) {
  //      str += tree.children.
  //      map {c => "  " * level + toStringRec(c, level + 1)}.
  //        reduce(_ + _)
  //    }
  //    str
  //  }
  //  toStringRec(this, 1)
  //}
}
